/*
    PROGRAMMER: ANTHONY FLORES-ALVAREZ
    COURSE: CS 216 - OOP IN C++
    DATE: NOVEMBER 5, 2020
    DESCRIPTION: THIS PROGRAM DEMONSTRATES AN ABSTRACT CLASS
    THAT HAS A PURE VIRTUAL MEMBER FUNCTION AS A STAND-IN FOR 
    AN ACTUAL SEQUENCE, AND TWO MEMBER FUNCTIONS THAT ARE PASSED
    TWO INTEGER PAREMETESR K AND M, WHERE K < M.
*/

// HEADER FILES FOR PROGRAM FUNCTIONALITY
#INCLUDE <IOSTREAM>
#INCLUDE <CMATH>
#INCLUDE <SSTREAM>
#INCLUDE <CSTDLIB>

// ALLOWS US TO NOT HAVE TO USE STD:: THROUGHOUT PROGRAM
USING NAMESPACE STD;

// CLASS DECLARATION FOR PROGRAM
CLASS ABSTRACTSEQ{

    // PUBLIC MEMBER FUNCTIONS & VARIABLES
    PUBLIC:

        // PURE VIRTUAL MEMBER FUNCTION AS A STAND-IN FOR 
        // AN ACTUAL SEQUENCE
        VIRTUAL INT FUN(INT K) = 0;

        // PRINTS ALL TERMS FUN(K) THROUGH FUN(M) OF SEQUENCE
        VOID PRINTSEQ(INT K, INT M){
            
            // LOOP THROUGH SEQUENCE UNTIL M
            WHILE(K <= M){
                
                // END OF SEQUENCE
                IF(K == M){

                    COUT << FUN(K) << ".";
                    K++;
                }

                // TERM IN SEQUENCE
                ELSE{

                    COUT << FUN(K) <<",";
                    K++;
                }
                
            }
        }

        // RETURNS SUM OF TERMS IN SEQUENCE
        INT SUMSEQ(INT K,INT M){

            INT SUM = 0;

            // LOOPS THROUGH SEQUENCE
            WHILE(K <= M){
                
                // SUMS SEQUENCE/FUN(K) TERMS
                SUM += FUN(K);
                K++;
            }

            // RETURNS SUM
            RETURN SUM;
        }
};

// SQUARE SEQUENCE SUBCLASS FOR ABSTRACTSEQ CLASS DEMONSTRATION
CLASS SQUARESEQDEM:PUBLIC ABSTRACTSEQ{

    PUBLIC:
        // SEQUENCE OF SQUARED VALUES
        INT FUN(INT K){
            
            RETURN (POW((K + 1), 2));
        }
};

// ODD SEQUENCE SUBCLASS FOR ABSTRACTSEQ CLASS DEMONSTRATION
CLASS ODDSEQDEM:PUBLIC ABSTRACTSEQ{

    PUBLIC:
        // SEQUENCE OF ODD NUMBERS
        INT FUN(INT K){
            
            RETURN 2 * K + 1;
        }
};

// SWITCHES STRING TO AN INTEGER
DOUBLE SWITCHTOINT(STRING USERSTRING){

    // STORES NUMBER FORM OF USER'S STRING
    DOUBLE USERVALUE;

    // CREATING OBJECT FROM THE STRINGSTREAM CLASS
    STRINGSTREAM USTR(USERSTRING);

    // PASSING THE STRING VALUE TO THE VARIABLE 
    // THAT'LL HOLD IT AS AN INTEGER TYPE
    USTR >> USERVALUE;

    // GIVING BACK THE SWITCHED VALUE TYPE
    RETURN USERVALUE;
}

// CHECKS IF A STRING HAS A CHARACTER IN IT
BOOL ISSTRING(STRING USERINPUTSTRING){
    
    // STORING WHETHER OR NOT THERE IS A CHARACTER
    BOOL STRINGHERE;
    
    // CHECKING USER STRING FOR CHARACTER
    FOR (INT I = 0; I < USERINPUTSTRING.LENGTH(); I++){

        // IF THERE'S NONE
        IF(ISALPHA(USERINPUTSTRING[I]) != TRUE){
            STRINGHERE = FALSE;
            CONTINUE;
        }
        // IF THERE IS
        ELSE{
            STRINGHERE = TRUE;
            BREAK;
        }
    }

    // GIVING BACK IF THERE IS OR ISN'T A CHARACTER
    RETURN STRINGHERE;
}

// ENSURES THAT THE USER ENTERS A VALID INPUT
STRING VALIDATEINPUT(STRING USERINPUTSTRING){

    // STORING CHARACTER OUTCOME AND NUMBER FORM OF USER'S VALUES
    BOOL STRINGHERE;
    DOUBLE USERINPUTVALUE;

    // CHECKING FOR STRING
    STRINGHERE = ISSTRING(USERINPUTSTRING);
    // STORING NUMBER VALUE
    USERINPUTVALUE = SWITCHTOINT(USERINPUTSTRING);

    // LOOPS UNTIL USER ENTERS A POSITIVE INTEGER
    WHILE (!CIN || USERINPUTVALUE < 0 || STRINGHERE == TRUE || USERINPUTVALUE != INT(USERINPUTVALUE)) {
        // HELPS IN CLEARING THE ERROR FLAGS WHICH ARE SET WHEN CIN FAILS TO INTERPRET THE INPUT.
        CIN.CLEAR();
        // HELPS IN REMOVING THE INPUT CONTENTS THAT COULD'VE CAUSED THE READ FAILURE
        CIN.IGNORE(1000,'\N');
        COUT << "-------------------------------------------------" << ENDL;
        // PROMPT TO ENTER ONLY POSITIVE INTEGERS
        COUT << "ERROR! PLEASE ENTER A POSITIVE INTEGER: ";
        CIN >> USERINPUTSTRING;
        USERINPUTVALUE = SWITCHTOINT(USERINPUTSTRING);
        STRINGHERE = ISSTRING(USERINPUTSTRING);
    }
    // GIVING BACK ADMISSIBLE VALUE
    RETURN USERINPUTSTRING;
}

// MAIN FUNCTION
INT MAIN(){

    // INITIALIAZING INTEGER PARAMETERS
    INT K,
        M;

    // FOR VALUE CHECKING
    STRING K_STRING,
           M_STRING;

    // INITIALIZING INSTANCES FOR CLASS DEMONSTRATION
    SQUARESEQDEM SQROBJECT;
    ODDSEQDEM ODDOBJECT;

    // INTRO/ HEADER
    COUT << "-------------------------------------------------" << ENDL;
    COUT << "WELCOME TO SEQUENCE SUM!" << ENDL;
    COUT << "-------------------------------------------------" << ENDL;
    COUT << "RULES:" << ENDL;
    COUT << "\N- THIS PROGRAM WILL SHOW YOU THE SQUARE AND ODD SEQUENCES " << ENDL;
    COUT << "  WITH YOUR GIVEN STARTING (K) AND ENDING (M) TERMS. " << ENDL;
    COUT << "- YOUR K VALUE MUST BE LESS THAN YOUR M VALUE! (K < M)" << ENDL;
    COUT << "- ONLY POSITIVE INTEGERS WILL BE ACCEPTED! " << ENDL;
    COUT << "-------------------------------------------------" << ENDL;
    COUT << "REMINDER: " << ENDL;
    COUT << "\N- 0 MARKS THE BEGINNING OF THE SEQUENCE. " << ENDL;
    COUT << "-------------------------------------------------" << ENDL;

    // STORING USER STARTING PLACE/TERM IN SEQUENCE
    COUT << "\NENTER THE STARTING TERM (K) FOR THE SEQUENCES: ";
    CIN >> K_STRING;

    // CHECKING IF VALUE IS VALID
    K_STRING = VALIDATEINPUT(K_STRING);
    // STORING VALID VALUE
    K = SWITCHTOINT(K_STRING);

    // STORING USER ENDING PLACE/TERM IN SEQUENCE
    COUT << "\NENTER THE ENDING TERM OF (M) FOR THE SEQUENCES: ";
    CIN >> M_STRING;

    // CHECKING IF VALUE IS VALID
    M_STRING = VALIDATEINPUT(M_STRING);
    // STORING VALID VALUE
    M = SWITCHTOINT(M_STRING);

    WHILE(K >= M){

        // HELPS IN CLEARING THE ERROR FLAGS WHICH ARE SET WHEN CIN FAILS TO INTERPRET THE INPUT.
        CIN.CLEAR();
        // HELPS IN REMOVING THE INPUT CONTENTS THAT COULD'VE CAUSED THE READ FAILURE
        CIN.IGNORE(1000,'\N');
        COUT << "-------------------------------------------------" << ENDL;
        COUT << "ERROR! (K) MUST BE LESS THAN (M). " << ENDL;
        COUT << "-------------------------------------------------" << ENDL;

        // PROMPT TO ENTER ONLY POSITIVE INTEGERS
        COUT << "ENTER A VALID K VALUE: ";
        CIN >> K_STRING;
        // CHECKING IF VALUE IS VALID
        K_STRING = VALIDATEINPUT(K_STRING);
        // STORING VALID VALUE
        K = SWITCHTOINT(K_STRING);

        COUT << "ENTER A VALID M VALUE: ";
        CIN >> M_STRING;
        COUT << "-------------------------------------------------" << ENDL;
        // CHECKING IF VALUE IS VALID
        M_STRING = VALIDATEINPUT(M_STRING);
        // STORING VALID VALUE
        M = SWITCHTOINT(M_STRING);
    }

    COUT << "-------------------------------------------------" << ENDL;
    COUT << "YOUR INPUTS: " << ENDL;
    COUT << "\NSTARTING ELEMENT IN SEQUENCE (K): " << K << ENDL;
    COUT << "ENDING ELEMENT IN SEQUENCE (M): " << M << ENDL;

    /* SQUARE OUTPUTS */
    // OUTPUTTING SQUARE SEQUENCE
    COUT << "\NSQUARE SEQUENCE W/ GIVEN INPUTS: ";
    SQROBJECT.PRINTSEQ(K, M);
    // OUTPUTTING SUMMED SEQUENCE TERMS
    COUT << "\NSUM OF SQUARE SEQUENCE: " << SQROBJECT.SUMSEQ(K, M) << ENDL;

    /* ODD OUTPUTS */
    // OUTPUTTING ODD SEQUENCE
    COUT << "\NODD SEQUENCE W/ GIVEN INPUTS: ";
    ODDOBJECT.PRINTSEQ(K, M);
    // OUTPUTTING SUMMED SEQUENCE TERMS
    COUT << "\NSUM OF ODD SEQUENCE: " << ODDOBJECT.SUMSEQ(K, M) << ENDL;

    // CLOSING
    COUT << "-------------------------------------------------" << ENDL;
    COUT << "THANK YOU! HAVE A NICE DAY! :)" << ENDL;
    COUT << "-------------------------------------------------" << ENDL;

    // TERMINATING PROGRAM
    RETURN 0;
}